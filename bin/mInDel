#!/usr/bin/perl -w

=head1 NAME

mInDel - an efficient pipeline for high-throughput InDel markers discovery.

=head1 DESCRIPTION

the pipeline accepts NGS data as input and then proceeds automatically to perform several independent analyses. 

 Author	: Yuanda Lv
 E-mail	: Lyd0527@126.com
 Date	: 10/06/2014
 Version: 1.0

mInDel includes four steps:

step1: Pre-processing
step2: de novo assembly
step3: generate overlap fragments
step4: design probes
step5: ePCR mapping
step6: InDel screening

parameter:

=cut

use strict;
use Config::Tiny;
use Getopt::Long;

my $usage = q/
mInDel v1.0 10-06-2014

USAGE:

mInDel [-a genotypeA] [-b genotypeB] [-c config_file] [-o output_dir]

Description:

parameter:
-a  dir:seq_platform(illu\/454):seq_type(paired\/single), example: genotypeA:illu:paired
-b  two modes:
    1.with ref. genome. directly input genome FASTA file. For example: b.fa
    2.without ref. genome. [seq_dir:seq_platform(illu\/454)]. For example: genotypeB:454
-c  config_file, default: .\/mindel.config
-o  output_dir

Example:
1. mInDel -a A_dir:illu -b B_dir:454:ref -c mindel.config -o AB_InDel_project
2. mInDel -a A_dir:illu -b B_dir/B.fa -c mindel.config -o AB_InDel_project

/;

die $usage."\n" if (@ARGV<1);


my $a;
my $b;
my @a_para;
my @b_para;
my $config;
my $output="AB_InDel_project";

GetOptions(
	'a:s'	=>\$a,
	'b:s'	=>\$b,
	'c:s'	=>\$config,
	'o:s'	=>\$output,
);

# Open the config
my $Config = Config::Tiny->read( "$config" );

# Reading properties
my $threads = $Config->{_}->{threads};

##step1
my $phred = $Config->{s1}->{phred_score};
my $length= $Config->{s1}->{length};

##step2
my $insert_size = $Config->{s2}->{insert_size};
my $kmer= $Config->{s2}->{kmer};
my $identity= $Config->{s2}->{identity};
my $overlap= $Config->{s2}->{overlap};
my $contig_len= $Config->{s2}->{contig_len};

##step3
my $win = $Config->{s3}->{window_size};
my $step = $Config->{s3}->{step_size};

##step4
my $size_min = $Config->{s4}->{size_min};
my $size_max = $Config->{s4}->{size_max};
my $size_opt = $Config->{s4}->{size_opt};
my $tm_min = $Config->{s4}->{tm_min};
my $tm_max = $Config->{s4}->{tm_max};
my $tm_opt = $Config->{s4}->{tm_opt};
my $product_range = $Config->{s4}->{product_range};

##step5
my $mismatch = $Config->{s5}->{mismatch};
my $product_max = $Config->{s5}->{product_max};
my $product_min = $Config->{s5}->{product_min};

#### Create output directory
if (!(-e "$output")) {
	mkdir "$output" or die;
}

#### Processing genotype A

@a_para= (split/:/,$a); ##split a input

print "**********************************\n";
print "*Genotype A will be processed... *\n";
print "**********************************\n";

print "Step1:Reads Trimming...";
if (!(-e "$output/1.Trimmed_A")) {
	mkdir "$output/1.Trimmed_A" or die;
}

my $QA="$a_para[0] $phred $length";
if ($a_para[1] eq "illu"){
	&trim_illu($QA);
}else{
	&trim_454($QA);
}
`mv $a_para[0]/*.trimmed $output/1.Trimmed_A`;
print "Done\n";

print "Step2:De novo assembly...";
if (!(-e "$output/2.Assembly_A")) {
	mkdir "$output/2.Assembly_A" or die;
}

if ($a_para[1] eq "illu"){
	&assem_illu("$output/1.Trimmed_A");
}else{
	&assem_454("$output/1.Trimmed_A");
}
`mv $output/1.Trimmed_A/new.*  $output/2.Assembly_A`;
print "Done\n";

print "Step3:Generate overlap fragments...";

if (!(-e "$output/3.Overlap_Fragments_A")) {
	mkdir "$output/3.Overlap_Fragments_A" or die;
}

&overlap();
print "Done\n";

print "Step4:Design probes ...";
if (!(-e "$output/4.Probes_A")) {
	mkdir "$output/4.Probes_A" or die;
}

&probe();
`mv p3* probes_A* $output/4.Probes_A`;
print "Done\n\n";

#### Processing genotype B
print "**********************************\n";
print "*Genotype B will be processed... *\n";
print "**********************************\n";

if ($b !~/:/){
	print "genotypeB has reference genome sequences. Convert to reference mode!\n";
	print "ignore Step1,Step2 !\n";
	print "create database directory...";
	if (!(-e "$output/db")) {
		mkdir "$output/db" or die;
	}
	`cp $b $output/db/db.fa`;
	print "Done\n";

}else{
	@b_para= (split/:/,$b); ##split b input

	print "Step1:Reads Trimming...";
	if (!(-e "$output/1.Trimmed_B")) {
		mkdir "$output/1.Trimmed_B" or die;
	}
	if ($a_para[1] eq "illu"){
		&trim_illu($QA);
	}else{
		&trim_454($QA);
	}
	`mv $a_para[0]/*.trimmed $output/1.Trimmed_B`;
	print "Done\n";

	print "Step2:De novo assembly...";
	if (!(-e "$output/2.Assembly_B")) {
		mkdir "$output/2.Assembly_B" or die;
	}

	if ($a_para[1] eq "illu"){
		&assem_illu("$output/1.Trimmed_B");
	}else{
		&assem_454("$output/1.Trimmed_B");
	}
	`mv $output/1.Trimmed_B/new.*  $output/2.Assembly_B`;
	print "Done\n";
	
	print "Step2:Create database...\n";
	if (!(-e "$output/db")) {
		mkdir "$output/db" or die;
	}
	`cp $output/2.Assembly_B/new.contig $output/db\/db.fa`;
	print "Done\n";

}

#### ePCR mapping to genotype B contigs/ref. genome
print "\n**********************************\n";
print "*Step5:ePCR mapping is running...*\n";
print "**********************************\n";

if (!(-e "$output/5.ePCR_mapping")) {
	mkdir "$output/5.ePCR_mapping" or die;
}

&ePCR();
`mv  target.sam target.size $output/5.ePCR_mapping`;
print "**********************************\n\n";

#### screening InDel between A and B
print "**********************************\n";
print "*Step6:InDel screening...        *\n";
print "**********************************\n";

if (!(-e "$output/6.InDel_screening")) {
	mkdir "$output/6.InDel_screening" or die;
}

open (OUT1,">$output/6.InDel_screening/Combine.txt");
open (OUT2,">$output/6.InDel_screening/Candidate_InDel.txt");
print OUT1 "ID\tForward Primer(5'-3')\tTm\tsize\tReverse Primer(5'-3')\tTm\tsize\tA_Product_size(bp)\tB_Product_size(bp)\n";
print OUT2 "ID\tForward Primer(5'-3')\tReverse Primer(5'-3')\tA_Product_size(bp)\tB_Product_size(bp)\tDelta(B-A)\n";
close OUT1;
close OUT2;

&indel();

print "All jobs have been finished. Enjoy~\n\n";


#subrout....
sub trim_illu{
	`trim_illu.sh @_`;
}
sub trim_454{
	`trim_454.sh @_`;
}
sub assem_illu{
	`de_novo_assembly_illu -d @_ -i trimmed -s $insert_size -k $kmer -p $threads -o @_/new`;
}
sub assem_454{
	`de_novo_assembly_454 -d @_ -i trimmed -i $identity -l $overlap -p $threads -a $contig_len -o @_/new`;
}
sub overlap{
	`overlap_fragments -i $output/2.Assembly_A/new.contig -o $output/3.Overlap_Fragments_A/A_fragments.fa -w $win -s $step`;
}
sub probe{
	`primer_design_batch -input $output/3.Overlap_Fragments_A\/A_fragments.fa -output probes_A -size_min $size_min -size_opt $size_opt -size_max $size_max -product_range $product_range -tm_min $tm_min -tm_opt $tm_opt -tm_max $tm_max`;
}
sub ePCR{
	`ePCR_mapping -i $output/4.Probes_A\/probes_A -d $output/db\/db.fa -m $mismatch -t $threads`;
}
sub indel{
	`InDel_screening $output/4.Probes_A/probes_A.list $output/5.ePCR_mapping/target.size >>$output/6.InDel_screening/Combine.txt`;
	`awk 'BEGIN {OFS=\"\t\"}{print \$1,\$2,\$5,\$8,\$9,\$9-\$8}' $output/6.InDel_screening/Combine.txt | awk '(\$6!=0)' >>$output/6.InDel_screening/Candidate_InDel.txt`;
}
